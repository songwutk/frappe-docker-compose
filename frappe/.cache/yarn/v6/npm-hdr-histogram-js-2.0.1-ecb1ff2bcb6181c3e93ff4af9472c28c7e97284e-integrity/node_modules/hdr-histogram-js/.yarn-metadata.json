{
  "manifest": {
    "name": "hdr-histogram-js",
    "version": "2.0.1",
    "description": "TypeScript port of HdrHistogram",
    "main": "dist/index.js",
    "browser": "dist/hdrhistogram.umd.js",
    "types": "dist/index.d.ts",
    "keywords": [
      "hdr-histogram",
      "hdr-histogram-js",
      "percentiles",
      "monitoring",
      "latency",
      "performance"
    ],
    "scripts": {
      "tsc": "tsc --skipLibCheck --outDir dist --declaration true --sourceMap true",
      "test": "jest",
      "build": "npm run tsc && npm run rollup",
      "prettier": "prettier --parser typescript -l src/**/*.ts",
      "prettier:fix": "prettier --write --parser typescript -l src/**/*.ts",
      "astest": "asp --verbose",
      "astest:ci": "asp --summary",
      "asbuild:untouched": "asc assembly/index.ts -b build/untouched.wasm -t build/untouched.wat --sourceMap --debug",
      "asbuild:optimized": "asc assembly/index.ts -b build/optimized.wasm -t build/optimized.wat --sourceMap -O3 --noAssert",
      "asbuild:base64": "echo \"/** @internal */\nexport const BINARY = \\\"$(node ./base64.js build/optimized.wasm)\\\";\" > src/wasm/generated-wasm.ts",
      "asbuild": "npm run asbuild:untouched && npm run asbuild:optimized && npm run asbuild:base64",
      "rollup": "rollup -c"
    },
    "repository": {
      "type": "git",
      "url": "git+https://github.com/HdrHistogram/HdrHistogramJS.git"
    },
    "author": {
      "name": "Alexandre Victoor"
    },
    "license": "BSD-2-Clause",
    "devDependencies": {
      "@as-pect/cli": "^4.0.0",
      "@types/benchmark": "^1.0.31",
      "@types/jest": "^25.2.1",
      "@types/node": "7.0.0",
      "assemblyscript": "^0.12",
      "benchmark": "^2.1.4",
      "benny": "^3.6.14",
      "fast-check": "^1.1.1",
      "jest": "25.1.x",
      "prettier": "^1.6.1",
      "rollup": "^2.8.2",
      "rollup-plugin-commonjs": "^10.1.0",
      "rollup-plugin-node-resolve": "^5.2.0",
      "rollup-plugin-terser": "^5.3.0",
      "rollup-plugin-typescript": "^1.0.1",
      "ts-jest": "25.0.x",
      "ts-loader": "^3.5.0",
      "ts-node": "^5.0.1",
      "typescript": "^3.7.1",
      "yargs": "^6.4.0"
    },
    "dependencies": {
      "@assemblyscript/loader": "^0.10.1",
      "base64-js": "^1.2.0",
      "pako": "^1.0.3"
    },
    "files": [
      ".",
      "dist"
    ],
    "_registry": "npm",
    "_loc": "/home/frappe/.cache/yarn/v6/npm-hdr-histogram-js-2.0.1-ecb1ff2bcb6181c3e93ff4af9472c28c7e97284e-integrity/node_modules/hdr-histogram-js/package.json",
    "readmeFilename": "README.md",
    "readme": "[![Build Status](https://travis-ci.org/HdrHistogram/HdrHistogramJS.svg?branch=master)](https://travis-ci.org/HdrHistogram/HdrHistogramJS)\n\n# HdrHistogramJS\n\nTypeScript port of HdrHistogram for NodeJS and web browsers.  \nSince version 2, HdrHistogramJS comes in 2 flavors: the good old TypeScript implementation and a brand new WebAssembly implementation!  \nThis new WebAssembly implementation leverages on AssemblyScript to bring a significant performance boost. Since some caution must be taken using this WebAssembly implementation it is not enabled by default.  \nCheck out the [WebAssembly section](#boosting-performances-with-webassembly-since-hdrhistogramjs-v2) for more details on this topic.  \nMost features from original Java HdrHistogram implementation are implemented, including the following ones:\n\n- regular latency recording\n- latency recording with coordinated omissions correction\n- resizable bucket based histograms\n- memory optimized packed histograms\n- add and substract histograms\n- encoding and decoding compressed histograms\n\n# Dataviz\n\nHdrHistogramJS allows to display histograms without server-side processing. Hence, within your browser, you can:\n\n- Display histograms with this slightly modified version of the [hdrhistogram plotter](https://hdrhistogram.github.io/HdrHistogramJSDemo/plotFiles.html). With this one you can use base64 v2 encoded histograms as inputs.\n- Analyze log files with this [log analyzer](https://hdrhistogram.github.io/HdrHistogramJSDemo/logparser.html), inspired from the original [java/swing based log analyzer](https://github.com/HdrHistogram/HistogramLogAnalyzer).\n\n# Getting started\n\nThis library is packaged as a UMD module, hence you can use it directly\nfrom JavaScript within a browser. To do so, you can simply include HdrHistogramJS file from github's release page:\n\n```\n<script src=\"https://github.com/HdrHistogram/HdrHistogramJS/releases/download/v2.0.1/hdrhistogram.umd.js\"></script>\n```\n\nThen you will have access to classes and functions of the APIs using \"hdr\" prefix.\n\nYou can also use HdrHistogramJS as a commonjs NodeJS module.\nUsing npm you can get HdrHIstogramJS with the following command:\n\n```\n  npm i hdr-histogram-js\n```\n\nOr if you like yarn better:\n\n```\n  yarn add hdr-histogram-js\n```\n\nNote for TypeScript developers: since HdrHistogramJS has been written in TypeScript, definition files are embedded, no additional task is needed to get them.\n\n# API\n\nThe examples below use ES6 syntax. You can check out demo sources\nfor examples on how to use HdrHistogram directly within a browser, you should\nnot have any surprise though.\n\n## Instantiate an histogram\n\nHdrHistogramJS provides several histogram implementations. The simplest way to get a new histogram instance is to use the _build()_ function. Here is how to use it:\n\n```\nimport * as hdr from \"hdr-histogram-js\"\n\nconst histogram = hdr.build();\n```\n\nIf you need more control on the memory footprint of the instantiated histogram, you can be more specific using and optionnal build request parameter:\n\n```\nimport * as hdr from \"hdr-histogram-js\"\n\nconst histogram\n  = hdr.build(\n    {\n      bitBucketSize: 32,                // may be 8, 16, 32, 64 or 'packed'\n      autoResize: true,                 // default value is true\n      lowestDiscernibleValue: 1,        // default value is also 1\n      highestTrackableValue: 2,         // can increase up to Number.MAX_SAFE_INTEGER\n      numberOfSignificantValueDigits: 3 // Number between 1 and 5 (inclusive)\n      useWebAssembly: false             // default value is false, see WebAssembly section for details\n    }\n  );\n\n```\n\nBitBucketSize 'packed' options is available since HdrHistogramJS v1.2 . Like the Java packed implementation, it has a very low memory footprint but it is way slower than regular bucket based implementation.\n\n## Record values and retrieve metrics\n\nOnce you have an histogram instance, in order to record a value you just need\nto call method recordValue() as below:\n\n```\nimport * as hdr from \"hdr-histogram-js\"\nconst histogram = hdr.build();\n...\nconst latency = 1234;\nhistogram.recordValue(latency);\n```\n\nThe number passed as a parameter is expected to be an integer. If it is not the case, the decimal part will be ignored.\n\nOnce you have recorded some values, you can get min, max, median values and of course percentiles values as shown below:\n\n```\nimport * as hdr from \"hdr-histogram-js\"\n\nconst h = hdr.build();\nh.recordValue(123);\nh.recordValue(122);\nh.recordValue(1244);\n\nconsole.log(h.minNonZeroValue);           // 122\nconsole.log(h.maxValue);                  // 1244\nconsole.log(h.mean);                      // 486.333...\nconsole.log(h.getValueAtPercentile(90));  // 1244 as well\nconsole.log(h.summary);                   // { \"p50\": 123, ... , max: 1244, totalCount: 3 }\n```\n\nIf youn need a live example you can also take alook at this [simple ping demo](https://hdrhistogram.github.io/HdrHistogramJSDemo/ping-demo.html) or this [HdrHistogramJS on HdrHistogramJS demo](https://hdrhistogram.github.io/HdrHistogramJSDemo/hdr-on-hdr.html).\n\nYou can also very easily generate a textual\nrepresentation of an histogram:\n\n```\nconsole.log(`Statistics ${h}`);\n\n// output will be:\n//\n// Statistics Histogram 32b {\n//  \"p50\": 123,\n//  \"p75\": 1240,\n//  \"p90\": 1240,\n//  \"p97_5\": 1240,\n//  \"p99\": 1240,\n//  \"p99_9\": 1240,\n//  \"p99_99\": 1240,\n//  \"p99_999\": 1240,\n//  \"max\": 1244,\n//  \"totalCount\": 3\n// }\n\n```\n\nYou can also general an exhaustive textual representation similar to the one generated by the original Java HdrHistogram implementation:\n\n```\nimport * as hdr from \"hdr-histogram-js\"\n\nconst histogram = hdr.build();\nhistogram.recordValue(25);\nhistogram.recordValue(50);\nhistogram.recordValue(75);\nconst output = histogram.outputPercentileDistribution();\n\n// output will be:\n//\n//       Value     Percentile TotalCount 1/(1-Percentile)\n//\n//      25.000 0.000000000000          1           1.00\n//  ...\n//      75.000 0.700000000000          3           3.33\n//      75.000 1.000000000000          3\n//#[Mean    =       50.000, StdDeviation   =       20.412]\n//#[Max     =       75.000, Total count    =            3]\n//#[Buckets =           43, SubBuckets     =         2048]\n\n```\n\n## Dealing with coordinated omissions\n\nIf you are recording values at a fixed rate,\nyou can correct coordinated omissions while recording values:\n\n```\nhistogram.recordValueWithExpectedInterval(1234, 100);\n```\n\nIf you prefer to apply correction afterward:\n\n```\nconst correctedHistogram\n  = histogram.copyCorrectedForCoordinatedOmission(100);\n```\n\n## Boosting performances with WebAssembly\n\nSince version 2, HdrHistogramJS leverages on WebAssembly to speed up computations. Depending on the use case, the performance boost can be as high as twice as fast :)  \nEverything has been done to make your life easier when using HdrHistogramJS WebAssembly implementation, but since the usage a little bit different WebAssembly is not enabled by default.  \nTo benefit from WebAssembly performance boost, there are three things to take care of:\n\n- Bootstrap the HdrHistogramJS WebAssembly module at application startup\n- Build a WebAssembly histogram setting the useWebAssembly flag to true\n- Explicitely ask to free up memory by calling _histogram.destroy()_ once an histogram is not needed anymore.\n\nEven if under the cover a WebAssembly histogram is very different from a regular JS based histogram, both provide exactly the same interface.  \nThe code fragment below shows how to instantiate a resizable 32 bits WebAssembly histogram:\n\n```\nimport * as hdr from \"hdr-histogram-js\"\n\n// If you are on the browser side, you need to\n// load asynchronously HdrHistogramJS WASM module\nawait hdr.initWebAssembly();\n\n// If you are on the server side, you can\n// load synchronously HdrHistogramJS WASM module\nhdr.initWebAssemblySync();\n\nconst histogram = hdr.build({ useWebAssembly: true });\n\n// you can now use your histogram the same way you would do\n// with a regular \"JS histogram\"\nhistogram.recordValue(42);\nconsole.log(histogram.outputPercentileDistribution());\n\n// free up memory once the histogram is not needed anymore,\n// otherwise WebAssembly memory footprint will keep growing\n// each time an histogram is created\nhistogram.destroy();\n\n```\n\nNote: If you want to use this feature on the browser side, along with the UMD package, you need to add external dependency\n\"pako\". \"pako\" is mandatory to bootstrap the WASM module which is compressed to save some weight.\n\n## Encode & decode\n\nYou can encode and decode base64 compressed histograms. Hence you can decode base64 compressed histograms produced by other implementations of HdrHistogram (Java, C#, Rust, ...).  \nThe code fragment below shows how to encode an histogram:\n\n```\nimport * as hdr from \"hdr-histogram-js\"\n\nconst histogram = hdr.build();\nhistogram.recordvalue(42);\nconst encodedString = hdr.encodeIntoBase64String(histogram);\n// gives something that looks like \"HISTFAAAAB542pNpmSzMwMDAxAABzFCaEUoz2X+AMIKZAEARAtM=\"\n```\n\nThen to decode an histogram you can use this chunk of code:\n\n```\nimport * as hdr from \"hdr-histogram-js\"\n\nconst encodedString = \"HISTFAAAAB542pNpmSzMwMDAxAABzFCaEUoz2X+AMIKZAEARAtM=\";\nconst histogram = hdr.decodeFromCompressedBase64(encodedString);\n```\n\nIn the above code fragment, 'histogram' is a regular 32b bucket histogram. Other types of histograms can be specified using additionnal parameters. Below a code fragment where a WebAssembly packed histogram is used:\n\n```\nimport * as hdr from \"hdr-histogram-js\"\n\nconst encodedString = \"HISTFAAAAB542pNpmSzMwMDAxAABzFCaEUoz2X+AMIKZAEARAtM=\";\nconst histogram = hdr.decodeFromCompressedBase64(encodedString, 'packed', true);\n```\n\nIf you want to use this feature along with the UMD package, you need to add external dependency\n\"pako\". \"pako\" is used for zlib compression. Using npm you should get\nit as a transitive dependency, otherwise you need to add it in\nyour html page.\n\nYou can check out [this demo](https://hdrhistogram.github.io/HdrHistogramJSDemo/decoding-demo.html) or this [plotter on steroid](https://hdrhistogram.github.io/HdrHistogramJSDemo/plotFiles.html) to see this feature live!  \n_Be aware that only latest V2 encoding has been implemented, please raise a github issue if you need to see other versions implemented_\n\n## Histogram logs\n\nHistogramLogWriter and HistogramLogReader classes have been migrated and the API is quite similar to the one you might have used with the Java version.\nBelow a simple usage example of the HistogramLogWriter, where the log contents are appended to a string variable:\n\n```\nimport * as hdr from \"hdr-histogram-js\"\n\nlet buffer: string;\nconst writer = new hdr.HistogramLogWriter(content => {\n  buffer += content;\n});\nconst histogram = hdr.build();\nhistogram.startTimeStampMsec = 1234001;\nhistogram.endTimeStampMsec   = 1235123;\n\n...\n\nhistogram.recordValue(123000);\n\nwriter.outputLogFormatVersion();\nwriter.outputLegend();\nwriter.outputIntervalHistogram(histogram);\n```\n\nAs for the reading part, if you know a little bit the Java version, the following code fragment will sound familiar:\n\n```\nconst reader = new hdr.HistogramLogReader(fileContent);\nlet histogram;\nwhile ((histogram = reader.nextIntervalHistogram()) != null) {\n  // iterate on all histogram log lines\n  ...\n\n}\n```\n\n# Performance tips\n\nHdrHistogramJS stores values in memory buckets. Memory footprint of an histogram heavily depends on 3 things:\n\n- the bucket size. A bucket can take 8, 16, 32 or 64 bits of memory. 32 bits buckets is the default.\n- the precision of the histogram (i.e. the number of significant value digits). You can have up to 5 value digits, 3 value digits (default) should be enough for most use cases.\n- the allowed range of values. You can tunned this range with constructor/builder parameters _lowestDiscernibleValue_ and _highestTrackableValue_. If you are not sure of these values, the best option is to use flag _autoResize_, set to true by default.\n\nWhile tunning memory footprint, _estimatedFootprintInBytes_ histogram property can get quite useful since it gives you a clear indicator of the memory cost:\n\n```\nconst histogram = hdr.build();\nconsole.log(histogram.estimatedFootprintInBytes);\n```\n\nIf in your context saving memory is more important than saving CPU cycles, 'packed' bucket size is highly recommended. Available since HdrHistogramJS v1.2.0, this mode enables a very effective memory compression algorithm:\n\n```\nconst histogram = hdr.build({ bitBucketSize: \"packed\" });\nconsole.log(histogram.estimatedFootprintInBytes);\n```\n\nLast but not least, unless you are targetting very old browsers or a very old NodeJS version, you should turn on WebAssembly mode. Available since HdrHistogramJS v2.0.0, this mode is often twice as fast as regular JS mode. Also all bucket size options are available with WebAssembly, including 'packed':\n\n```\nconst histogram = hdr.build({ bitBucketSize: \"packed\", useWebAssembly: true });\nconsole.log(histogram.estimatedFootprintInBytes);\n```\n\n# Tree Shaking\n\nThe above examples use a convenient 'barrel' index file. Using this barrel, you cannot leverage on the tree shaking features of your favorite bundler. Hence the size of your JavaScript bundle may increase significantly. If you need to optimize the size of your bundle, you can import HdrHistogram modules as shown in code fragment below:\n\n```\nimport Int32Histogram from \"hdr-histogram-js/dist/Int32Histogram\"\n\nconst histogram = new Int32Histogram(1, 2, 3);\nhistogram.autoResize = true;\n\nhistogram.recordValue(...);\n\n```\n\n# Migrating from v1 to v2\n\nFor most users, migration from HdrHistogramJS v1 to v2 should be smooth. However since HdrHistogramJS v2 does not stick anymore with HdrHistogram Java API, you might run into some breaking changes.  \nPrior to v2, _hdr.build()_ was returning an _AbstractHistogram_ instance. _AbstractHistogram_ does not exist anymore and has been replaced by the _Histogram_ interface. Most methods from _AbstractHistogram_ still exist in new interface _Histogram_, however in order to have a more JS idiomatic API, getter methods such as _getMean()_ or _getTotalCount()_ have been replaced by JS properties:\n\n```\n// HdrHistogramJS v1\nconst histogram: AbstractHistogram = hdr.build();\nconst statistics = {\n  count: histogram.getTotalCount(),\n  mean: histogram.getMean(),\n  p99: histogram.getValueAtPercentile(99),\n}\n\n// becomes with HdrHistogramJS v2\nconst histogram: Histogram = hdr.build();\nconst statistics = {\n  count: histogram.totalCount,\n  mean: histogram.mean,\n  p99: histogram.getValueAtPercentile(99),\n}\n```\n\nModule paths also change a little bit with v2. Hence if you were importing specific modules as described in the tree shaking section, you need to change a little bit your code as below:\n\n```\n// HdrHistogramJS v1\nimport AbstractHistogram from \"hdr-histogram-js/AbstractHistogram\"\nimport Int32Histogram from \"hdr-histogram-js/Int32Histogram\"\n\n// becomes with HdrHistogramJS v2\nimport Histogram from \"hdr-histogram-js/dist/Histogram\"\nimport Int32Histogram from \"hdr-histogram-js/dist/Int32Histogram\"\n```\n\n# Design & Limitations\n\nThe code is almost a direct port of the Java version.\nOptimisation based on inheritance to avoid false sharing\nmight not be relevant in JS, but I believe that keeping\nthe same code structure might be handy to keep the code up to date\nwith the Java version in the future.\n\nMain limitations comes from number support in JavaScript.\nThere is no such thing as 64b integers in JavaScript. Everything is \"number\",\nand a number is safe as an integer up to 2^53.  \nThe most annoying issue encountered during the code migration,\nis that bit operations, heavily used within original HdrHistogram,\nonly work on the first 32 bits. That means that the following JavaScript expression is evaluated as true:\n\n```\nMath.pow(2, 31) << 1 === 0   // sad but true\n```\n\nAnyway bit shift operations are not really optimized\nin most browser, so... everything related to bits have been\nconverted to good old arithmetic expressions in the process\nof converting the Java code to TypeScript.  \nWith WebAssembly and AssemblyScript things are different. HdrHistogramsJS AssemblyScript source code is closer to the original Java code since all the limitations mentioned above does not apply to WebAssembly :)\n",
    "licenseText": "BSD 2-Clause License\n\nCopyright (c) 2016, Alexandre Victoor\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/hdr-histogram-js/-/hdr-histogram-js-2.0.1.tgz#ecb1ff2bcb6181c3e93ff4af9472c28c7e97284e",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/hdr-histogram-js/-/hdr-histogram-js-2.0.1.tgz",
    "hash": "ecb1ff2bcb6181c3e93ff4af9472c28c7e97284e",
    "integrity": "sha512-uPZxl1dAFnjUFHWLZmt93vUUvtHeaBay9nVNHu38SdOjMSF/4KqJUqa1Seuj08ptU1rEb6AHvB41X8n/zFZ74Q==",
    "registry": "npm",
    "packageName": "hdr-histogram-js",
    "cacheIntegrity": "sha512-uPZxl1dAFnjUFHWLZmt93vUUvtHeaBay9nVNHu38SdOjMSF/4KqJUqa1Seuj08ptU1rEb6AHvB41X8n/zFZ74Q== sha1-7LH/K8thgcPpP/SvlHLCjH6XKE4="
  },
  "registry": "npm",
  "hash": "ecb1ff2bcb6181c3e93ff4af9472c28c7e97284e"
}