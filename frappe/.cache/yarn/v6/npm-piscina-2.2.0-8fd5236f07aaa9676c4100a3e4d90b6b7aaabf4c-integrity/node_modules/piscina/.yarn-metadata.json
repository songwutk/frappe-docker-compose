{
  "manifest": {
    "name": "piscina",
    "version": "2.2.0",
    "description": "A fast, efficient Node.js Worker Thread Pool implementation",
    "main": "./dist/src/index.js",
    "exports": {
      "import": "./dist/esm-wrapper.mjs",
      "require": "./dist/src/index.js"
    },
    "types": "./dist/src/index.d.ts",
    "scripts": {
      "build": "tsc && gen-esm-wrapper . dist/esm-wrapper.mjs",
      "lint": "standardx \"**/*.{ts,mjs,js,cjs}\" | snazzy",
      "test": "npm run lint && npm run build && npm run test-only",
      "test-only": "tap",
      "prepack": "npm run build"
    },
    "repository": {
      "type": "git",
      "url": "git+https://github.com/piscinajs/piscina.git"
    },
    "keywords": [
      "fast",
      "worker threads",
      "thread pool",
      "wade wilson"
    ],
    "author": {
      "name": "James M Snell",
      "email": "jasnell@gmail.com"
    },
    "contributors": [
      {
        "name": "Anna Henningsen",
        "email": "anna@addaleax.net"
      },
      {
        "name": "Matteo Collina",
        "email": "matteo.collina@gmail.com"
      }
    ],
    "license": "MIT",
    "devDependencies": {
      "@types/node": "^14.14.31",
      "@typescript-eslint/eslint-plugin": "^4.15.1",
      "@typescript-eslint/parser": "^4.15.1",
      "abort-controller": "^3.0.0",
      "concat-stream": "^2.0.0",
      "gen-esm-wrapper": "^1.1.1",
      "snazzy": "^9.0.0",
      "standardx": "^7.0.0",
      "tap": "^14.11.0",
      "typescript": "^4.1.5"
    },
    "dependencies": {
      "eventemitter-asyncresource": "^1.0.0",
      "hdr-histogram-js": "^2.0.1",
      "hdr-histogram-percentiles-obj": "^3.0.0"
    },
    "optionalDependencies": {
      "nice-napi": "^1.0.2"
    },
    "eslintConfig": {
      "rules": {
        "semi": [
          "error",
          "always"
        ],
        "no-unused-vars": "off",
        "no-use-before-define": "off",
        "no-unreachable-loop": "off",
        "no-dupe-class-members": "off",
        "@typescript-eslint/no-unused-vars": "error"
      },
      "globals": {
        "SharedArrayBuffer": true,
        "Atomics": true,
        "AbortController": true,
        "MessageChannel": true
      }
    },
    "standardx": {
      "parser": "@typescript-eslint/parser",
      "plugins": [
        "@typescript-eslint/eslint-plugin"
      ]
    },
    "bugs": {
      "url": "https://github.com/piscinajs/piscina/issues"
    },
    "homepage": "https://github.com/piscinajs/piscina#readme",
    "_registry": "npm",
    "_loc": "/home/frappe/.cache/yarn/v6/npm-piscina-2.2.0-8fd5236f07aaa9676c4100a3e4d90b6b7aaabf4c-integrity/node_modules/piscina/package.json",
    "readmeFilename": "README.md",
    "readme": "![Piscina Logo](https://avatars1.githubusercontent.com/u/65627548?s=200&v=4)\n\n# piscina - the node.js worker pool\n\n![CI](https://github.com/jasnell/piscina/workflows/CI/badge.svg)\n\n* ✔ Fast communication between threads\n* ✔ Covers both fixed-task and variable-task scenarios\n* ✔ Supports flexible pool sizes\n* ✔ Proper async tracking integration\n* ✔ Tracking statistics for run and wait times\n* ✔ Cancellation Support\n* ✔ Supports enforcing memory resource limits\n* ✔ Supports CommonJS, ESM, and TypeScript\n* ✔ Custom task queues\n* ✔ Optional CPU scheduling priorities on Linux\n\nWritten in TypeScript.\n\nFor Node.js 12.x and higher.\n\n[MIT Licensed][].\n\n## Piscina API\n\n### Example\n\nIn `main.js`:\n\n```js\nconst Piscina = require('piscina');\n\nconst piscina = new Piscina({\n  filename: path.resolve(__dirname, 'worker.js')\n});\n\n(async function() {\n  const result = await piscina.runTask({ a: 4, b: 6 });\n  console.log(result);  // Prints 10\n})();\n```\n\nIn `worker.js`:\n\n```js\nmodule.exports = ({ a, b }) => {\n  return a + b;\n};\n```\n\nThe worker may also be an async function or may return a Promise:\n\n```js\nconst { promisify } = require('util');\nconst sleep = promisify(setTimeout);\n\nmodule.exports = async ({ a, b } => {\n  // Fake some async activity\n  await sleep(100);\n  return a + b;\n})\n```\n\nESM is also supported for both Piscina and workers:\n\n```js\nimport { Piscina } from 'piscina';\n\nconst piscina = new Piscina({\n  // The URL must be a file:// URL\n  filename: new URL('./worker.mjs', import.meta.url).href\n});\n\n(async function () {\n  const result = await piscina.runTask({ a: 4, b: 6 });\n  console.log(result); // Prints 10\n})();\n```\n\nIn `worker.mjs`:\n\n```js\nexport default ({ a, b }) => {\n  return a + b;\n};\n```\n\n### Cancelable Tasks\n\nSubmitted tasks may be canceled using either an `AbortController` or\nan `EventEmitter`:\n\n```js\n'use strict';\n\nconst Piscina = require('piscina');\nconst { AbortController } = require('abort-controller');\nconst { resolve } = require('path');\n\nconst piscina = new Piscina({\n  filename: resolve(__dirname, 'worker.js')\n});\n\n(async function() {\n  const abortController = new AbortController();\n  try {\n    const task = piscina.runTask({ a: 4, b: 6 }, abortController.signal);\n    abortController.abort();\n    await task;\n  } catch (err) {\n    console.log('The task was canceled');\n  }\n})();\n```\n\nTo use `AbortController`, you will need to `npm i abort-controller`\n(or `yarn add abort-controller`).\n\n(In Node.js 15.0.0 or higher, there is a new built-in `AbortController`\nimplementation that can be used here as well.)\n\nAlternatively, any `EventEmitter` that emits an `'abort'` event\nmay be used as an abort controller:\n\n```js\n'use strict';\n\nconst Piscina = require('piscina');\nconst EventEmitter = require('events');\nconst { resolve } = require('path');\n\nconst piscina = new Piscina({\n  filename: resolve(__dirname, 'worker.js')\n});\n\n(async function() {\n  const ee = new EventEmitter();\n  try {\n    const task = piscina.runTask({ a: 4, b: 6 }, ee);\n    ee.emit('abort');\n    await task;\n  } catch (err) {\n    console.log('The task was canceled');\n  }\n})();\n```\n\n### Delaying Availability of Workers\n\nA worker thread will not be made available to process tasks until Piscina\ndetermines that it is \"ready\". By default, a worker is ready as soon as\nPiscina loads it and acquires a reference to the exported handler function.\n\nThere may be times when the availability of a worker may need to be delayed\nlonger while the worker initializes any resources it may need to operate.\nTo support this case, the worker module may export a `Promise` that resolves\nthe handler function as opposed to exporting the function directly:\n\n```js\nasync function initialize() {\n  await someAsyncInitializationActivity();\n  return ({ a, b }) => a + b;\n}\n\nmodule.exports = initialize();\n```\n\nPiscina will await the resolution of the exported Promise before marking\nthe worker thread available.\n\n### Backpressure\n\nWhen the `maxQueue` option is set, once the `Piscina` queue is full, no\nadditional tasks may be submitted until the queue size falls below the\nlimit. The `'drain'` event may be used to receive notification when the\nqueue is empty and all tasks have been submitted to workers for processing.\n\nExample: Using a Node.js stream to feed a Piscina worker pool:\n```js\n'use strict';\n\nconst { resolve } = require('path');\nconst Pool = require('../..');\n\nconst pool = new Pool({\n  filename: resolve(__dirname, 'worker.js'),\n  maxQueue: 'auto'\n});\n\nconst stream = getStreamSomehow();\nstream.setEncoding('utf8');\n\npool.on('drain', () => {\n  if (stream.isPaused()) {\n    console.log('resuming...', counter, pool.queueSize);\n    stream.resume();\n  }\n});\n\nstream\n  .on('data', (data) => {\n    pool.runTask(data);\n    if (pool.queueSize === pool.options.maxQueue) {\n      console.log('pausing...', counter, pool.queueSize);\n      stream.pause();\n    }\n  })\n  .on('error', console.error)\n  .on('end', () => {\n    console.log('done');\n  });\n```\n\n### Additional Examples\n\nAdditional examples can be found in the GitHub repo at\nhttps://github.com/jasnell/piscina/tree/master/examples\n\n## Class: `Piscina`\n\nPiscina works by creating a pool of Node.js Worker Threads to which\none or more tasks may be dispatched. Each worker thread executes a\nsingle exported function defined in a separate file. Whenever a\ntask is dispatched to a worker, the worker invokes the exported\nfunction and reports the return value back to Piscina when the\nfunction completes.\n\nThis class extends [`EventEmitter`][] from Node.js.\n\n### Constructor: `new Piscina([options])`\n\n* The following optional configuration is supported:\n  * `filename`: (`string | null`) Provides the default source for the code that\n    runs the tasks on Worker threads. This should be an absolute path or an\n    absolute `file://` URL to a file that exports a JavaScript `function` or\n    `async function` as its default export or `module.exports`. [ES modules][]\n    are supported.\n  * `minThreads`: (`number`) Sets the minimum number of threads that are always\n    running for this thread pool. The default is based on the number of\n    available CPUs.\n  * `maxThreads`: (`number`) Sets the maximum number of threads that are\n    running for this thread pool. The default is based on the number of\n    available CPUs.\n  * `idleTimeout`: (`number`) A timeout in milliseconds that specifies how long\n    a `Worker` is allowed to be idle, i.e. not handling any tasks, before it is\n    shut down. By default, this is immediate. **Tip**: *The default `idleTimeout`\n    can lead to some performance loss in the application because of the overhead\n    involved with stopping and starting new worker threads. To improve performance,\n    try setting the `idleTimeout` explicitly.*\n  * `maxQueue`: (`number` | `string`) The maximum number of tasks that may be\n    scheduled to run, but not yet running due to lack of available threads, at\n    a given time. By default, there is no limit. The special value `'auto'`\n    may be used to have Piscina calculate the maximum as the square of `maxThreads`.\n    When `'auto'` is used, the calculated `maxQueue` value may be found by checking\n    the [`options.maxQueue`](#property-options-readonly) property.\n  * `concurrentTasksPerWorker`: (`number`) Specifies how many tasks can share\n    a single Worker thread simultaneously. The default is `1`. This generally\n    only makes sense to specify if there is some kind of asynchronous component\n    to the task. Keep in mind that Worker threads are generally not built for\n    handling I/O in parallel.\n  * `useAtomics`: (`boolean`) Use the [`Atomics`][] API for faster communication\n    between threads. This is on by default.\n  * `resourceLimits`: (`object`) See [Node.js new Worker options][]\n    * `maxOldGenerationSizeMb`: (`number`) The maximum size of each worker threads\n      main heap in MB.\n    * `maxYoungGenerationSizeMb`: (`number`) The maximum size of a heap space for\n      recently created objects.\n    * `codeRangeSizeMb`: (`number`) The size of a pre-allocated memory range used\n      for generated code.\n    * `stackSizeMb` : (`number`) The default maximum stack size for the thread.\n      Small values may lead to unusable Worker instances. Default: 4\n  * `env`: (`object`) If set, specifies the initial value of `process.env` inside\n    the worker threads. See [Node.js new Worker options][] for details.\n  * `argv`: (`any[]`) List of arguments that will be stringified and appended to\n    `process.argv` in the worker. See [Node.js new Worker options][] for details.\n  * `execArgv`: (`string[]`) List of Node.js CLI options passed to the worker.\n    See [Node.js new Worker options][] for details.\n  * `workerData`: (`any`) Any JavaScript value that can be cloned and made\n    available as `require('piscina').workerData`. See [Node.js new Worker options][]\n    for details. Unlike regular Node.js Worker Threads, `workerData` must not\n    specify any value requiring a `transferList`. This is because the `workerData`\n    will be cloned for each pooled worker.\n  * `taskQueue`: (`TaskQueue`) By default, Piscina uses a first-in-first-out\n    queue for submitted tasks. The `taskQueue` option can be used to provide an\n    alternative implementation. See [Custom Task Queues][] for additional detail.\n  * `niceIncrement`: (`number`) An optional value that decreases priority for\n    the individual threads, i.e. the higher the value, the lower the priority\n    of the Worker threads. This value is only used on Linux and requires the\n    optional [`nice-napi`][] module to be installed.\n    See [`nice(2)`][] for more details.\n  * `trackUnmanagedFds`: (`boolean`) An optional setting that, when `true`, will\n    cause Workers to track file descriptors managed using `fs.open()` and\n    `fs.close()`, and will close them automatically when the Worker exits.\n    Defaults to `true`. (This option is only supported on Node.js 12.19+ and\n    all Node.js versions higher than 14.6.0).\n\nUse caution when setting resource limits. Setting limits that are too low may\nresult in the `Piscina` worker threads being unusable.\n\n### Method: `runTask(task[, transferList][, filename][, abortSignal])`\n\nSchedules a task to be run on a Worker thread.\n\n* `task`: Any value. This will be passed to the function that is exported from\n  `filename`.\n* `transferList`: An optional lists of objects that is passed to\n  [`postMessage()`] when posting `task` to the Worker, which are transferred\n  rather than cloned.\n* `filename`: Optionally overrides the `filename` option passed to the\n  constructor for this task. If no `filename` was specified to the constructor,\n  this is mandatory.\n* `abortSignal`: An [`AbortSignal`][] instance. If passed, this can be used to\n  cancel a task. If the task is already running, the corresponding `Worker`\n  thread will be stopped.\n  (More generally, any `EventEmitter` or `EventTarget` that emits `'abort'`\n  events can be passed here.) Abortable tasks cannot share threads regardless\n  of the `concurrentTasksPerWorker` options.\n\nThis returns a `Promise` for the return value of the (async) function call\nmade to the function exported from `filename`. If the (async) function throws\nan error, the returned `Promise` will be rejected with that error.\nIf the task is aborted, the returned `Promise` is rejected with an error\nas well.\n\n### Method: `destroy()`\n\nStops all Workers and rejects all `Promise`s for pending tasks.\n\nThis returns a `Promise` that is fulfilled once all threads have stopped.\n\n### Event: `'error'`\n\nAn `'error'` event is emitted by instances of this class when:\n\n- Uncaught exceptions occur inside Worker threads that do not currently handle\n  tasks.\n- Unexpected messages are sent from from Worker threads.\n\nAll other errors are reported by rejecting the `Promise` returned from\n`runTask()`, including rejections reported by the handler function itself.\n\n### Event: `'drain'`\n\nA `'drain'` event is emitted whenever the `queueSize` reaches `0`.\n\n### Property: `completed` (readonly)\n\nThe current number of completed tasks.\n\n### Property: `duration` (readonly)\n\nThe length of time (in milliseconds) since this `Piscina` instance was\ncreated.\n\n### Property: `options` (readonly)\n\nA copy of the options that are currently being used by this instance. This\nobject has the same properties as the options object passed to the constructor.\n\n### Property: `runTime` (readonly)\n\nA histogram summary object summarizing the collected run times of completed\ntasks. All values are expressed in milliseconds.\n\n* `runTime.average` {`number`} The average run time of all tasks\n* `runTime.mean` {`number`} The mean run time of all tasks\n* `runTime.stddev` {`number`} The standard deviation of collected run times\n* `runTime.min` {`number`} The fastest recorded run time\n* `runTime.max` {`number`} The slowest recorded run time\n\nAll properties following the pattern `p{N}` where N is a number (e.g. `p1`, `p99`)\nrepresent the percentile distributions of run time observations. For example,\n`p99` is the 99th percentile indicating that 99% of the observed run times were\nfaster or equal to the given value.\n\n```js\n{\n  average: 1880.25,\n  mean: 1880.25,\n  stddev: 1.93,\n  min: 1877,\n  max: 1882.0190887451172,\n  p0_001: 1877,\n  p0_01: 1877,\n  p0_1: 1877,\n  p1: 1877,\n  p2_5: 1877,\n  p10: 1877,\n  p25: 1877,\n  p50: 1881,\n  p75: 1881,\n  p90: 1882,\n  p97_5: 1882,\n  p99: 1882,\n  p99_9: 1882,\n  p99_99: 1882,\n  p99_999: 1882\n}\n```\n\n### Property: `threads` (readonly)\n\nAn Array of the `Worker` instances used by this pool.\n\n### Property: `queueSize` (readonly)\n\nThe current number of tasks waiting to be assigned to a Worker thread.\n\n### Property: `utilization` (readonly)\n\nA point-in-time ratio comparing the approximate total mean run time\nof completed tasks to the total runtime capacity of the pool.\n\nA pools runtime capacity is determined by multiplying the `duration`\nby the `options.maxThread` count. This provides an absolute theoretical\nmaximum aggregate compute time that the pool would be capable of.\n\nThe approximate total mean run time is determined by multiplying the\nmean run time of all completed tasks by the total number of completed\ntasks. This number represents the approximate amount of time the\npool as been actively processing tasks.\n\nThe utilization is then calculated by dividing the approximate total\nmean run time by the capacity, yielding a fraction between `0` and `1`.\n\n### Property: `waitTime` (readonly)\n\nA histogram summary object summarizing the collected times tasks spent\nwaiting in the queue. All values are expressed in milliseconds.\n\n* `waitTime.average` {`number`} The average wait time of all tasks\n* `waitTime.mean` {`number`} The mean wait time of all tasks\n* `waitTime.stddev` {`number`} The standard deviation of collected wait times\n* `waitTime.min` {`number`} The fastest recorded wait time\n* `waitTime.max` {`number`} The longest recorded wait time\n\nAll properties following the pattern `p{N}` where N is a number (e.g. `p1`, `p99`)\nrepresent the percentile distributions of wait time observations. For example,\n`p99` is the 99th percentile indicating that 99% of the observed wait times were\nfaster or equal to the given value.\n\n```js\n{\n  average: 1880.25,\n  mean: 1880.25,\n  stddev: 1.93,\n  min: 1877,\n  max: 1882.0190887451172,\n  p0_001: 1877,\n  p0_01: 1877,\n  p0_1: 1877,\n  p1: 1877,\n  p2_5: 1877,\n  p10: 1877,\n  p25: 1877,\n  p50: 1881,\n  p75: 1881,\n  p90: 1882,\n  p97_5: 1882,\n  p99: 1882,\n  p99_9: 1882,\n  p99_99: 1882,\n  p99_999: 1882\n}\n```\n\n### Static property: `isWorkerThread` (readonly)\n\nIs `true` if this code runs inside a `Piscina` threadpool as a Worker.\n\n### Static property: `version` (readonly)\n\nProvides the current version of this library as a semver string.\n\n### Static method: `move(value)`\n\nBy default, any value returned by a worker function will be cloned when\nreturned back to the Piscina pool, even if that object is capable of\nbeing transfered. The `Piscina.move()` method can be used to wrap and\nmark transferable values such that they will by transfered rather than\ncloned.\n\nThe `value` may be any object supported by Node.js to be transferable\n(e.g. `ArrayBuffer`, any `TypedArray`, or `MessagePort`), or any object\nimplementing the `Transferable` interface.\n\n```js\nconst { move } = require('piscina');\n\nmodule.exports = () => {\n  return move(new ArrayBuffer(10));\n}\n```\n\nThe `move()` method will throw if the `value` is not transferable.\n\nThe object returned by the `move()` method should not be set as a\nnested value in an object. If it is used, the `move()` object itself\nwill be cloned as opposed to transfering the object it wraps.\n\n#### Interface: `Transferable`\n\nObjects may implement the `Transferable` interface to create their own\ncustom transferable objects. This is useful when an object being\npassed into or from a worker contains a deeply nested transferable\nobject such as an `ArrayBuffer` or `MessagePort`.\n\n`Transferable` objects expose two properties inspected by Piscina\nto determine how to transfer the object. These properties are\nnamed using the special static `Piscina.transferableSymbol` and\n`Piscina.valueSymbol` properties:\n\n* The `Piscina.transferableSymbol` property provides the object\n  (or objects) that are to be included in the `transferList`.\n\n* The `Piscina.valueSymbol` property provides a surrogate value\n  to transmit in place of the `Transferable` itself.\n\nBoth properties are required.\n\nFor example,\n\n```js\nconst {\n  move,\n  transferableSymbol,\n  valueSymbol\n} = require('piscina');\n\nmodule.exports = () => {\n  const obj = {\n    a: { b: new Uint8Array(5); },\n    c: { new Uint8Array(10); },\n\n    get [transferableSymbol]() {\n      // Transfer the two underlying ArrayBuffers\n      return [this.a.b.buffer, this.c.buffer];\n    }\n\n    get [valueSymbol]() {\n      return { a: { b: this.a.b }, c: this.c };\n    }\n  };\n  return move(obj);\n};\n```\n\n## Custom Task Queues\n\nBy default, Piscina uses a simple array-based first-in-first-out (fifo)\ntask queue. When a new task is submitted and there are no available\nworkers, tasks are pushed on to the queue until a worker becomes\navailable.\n\nIf the default fifo queue is not sufficient, user code may replace the\ntask queue implementation with a custom implementation using the\n`taskQueue` option on the Piscina constructor.\n\nCustom task queue objects *must* implement the `TaskQueue` interface,\ndescribed below using TypeScript syntax:\n\n```ts\ninterface Task {\n  readonly [Piscina.queueOptionsSymbol] : object | null;\n}\n\ninterface TaskQueue {\n  readonly size : number;\n  shift () : Task | null;\n  remove (task : Task) : void;\n  push (task : Task) : void;\n}\n```\n\nAn example of a custom task queue that uses a shuffled priority queue\nis available in [`examples/task-queue`](./examples/task-queue/index.js);\n\nThe special symbol `Piscina.queueOptionsSymbol` may be set as a property\non tasks submitted to `runTask()` as a way of passing additional options\non to the custom `TaskQueue` implementation. (Note that because the\nqueue options are set as a property on the task, tasks with queue\noptions cannot be submitted as JavaScript primitives).\n\n## Current Limitations (Things we're working on / would love help with)\n\n* Improved Documentation\n* Benchmarks\n\n## Performance Notes\n\nWorkers are generally optimized for offloading synchronous,\ncompute-intensive operations off the main Node.js event loop thread.\nWhile it is possible to perform asynchronous operations and I/O\nwithin a Worker, the performance advantages of doing so will be\nminimal.\n\nSpecifically, it is worth noting that asynchronous operations\nwithin Node.js, including I/O such as file system operations\nor CPU-bound tasks such as crypto operations or compression\nalgorithms, are already performed in parallel by Node.js and\nlibuv on a per-process level. This means that there will be\nlittle performance impact on moving such async operations into\na Piscina worker (see examples/scrypt for example).\n\n### Queue Size\n\nPiscina provides the ability to configure the minimum and\nmaximum number of worker threads active in the pool, as well as\nset limits on the number of tasks that may be queued up waiting\nfor a free worker. It is important to note that setting the\n`maxQueue` size too high relative to the number of worker threads\ncan have a detrimental impact on performance and memory usage.\nSetting the `maxQueue` size too small can also be problematic\nas doing so could cause your worker threads to become idle and\nbe shutdown. Our testing has shown that a `maxQueue` size of\napproximately the square of the maximum number of threads is\ngenerally sufficient and performs well for many cases, but this\nwill vary significantly depending on your workload. It will be\nimportant to test and benchmark your worker pools to ensure you've\neffectively balanced queue wait times, memory usage, and worker\npool utilization.\n\n### Queue Pressure and Idle Threads\n\nThe thread pool maintained by Piscina has both a minimum and maximum\nlimit to the number of threads that may be created. When a Piscina\ninstance is created, it will spawn the minimum number of threads\nimmediately, then create additional threads as needed up to the\nlimit set by `maxThreads`. Whenever a worker completes a task, a\ncheck is made to determine if there is additional work for it to\nperform. If there is no additional work, the thread is marked idle.\nBy default, idle threads are shutdown immediately, with Piscina\nensuring that the pool always maintains at least the minimum.\n\nWhen a Piscina pool is processing a stream of tasks (for instance,\nprocessing http server requests as in the React server-side\nrendering example in examples/react-ssr), if the rate in which\nnew tasks are received and queued is not sufficient to keep workers\nfrom going idle and terminating, the pool can experience a thrashing\neffect -- excessively creating and terminating workers that will\ncause a net performance loss. There are a couple of strategies to\navoid this churn:\n\nStrategy 1: Ensure that the queue rate of new tasks is sufficient to\nkeep workers from going idle. We refer to this as \"queue pressure\".\nIf the queue pressure is too low, workers will go idle and terminate.\nIf the queue pressure is too high, tasks will stack up, experience\nincreased wait latency, and consume additional memory.\n\nStrategy 2: Increase the `idleTimeout` configuration option. By\ndefault, idle threads terminate immediately. The `idleTimeout` option\ncan be used to specify a longer period of time to wait for additional\ntasks to be submitted before terminating the worker. If the queue\npressure is not maintained, this could result in workers sitting idle\nbut those will have less of a performance impact than the thrashing\nthat occurs when threads are repeatedly terminated and recreated.\n\nStrategy 3: Increase the `minThreads` configuration option. This has\nthe same basic effect as increasing the `idleTimeout`. If the queue\npressure is not high enough, workers may sit idle indefinitely but\nthere will be less of a performance hit.\n\nIn applications using Piscina, it will be most effective to use a\ncombination of these three approaches and tune the various configuration\nparameters to find the optimum combination both for the application\nworkload and the capabilities of the deployment environment. There\nare no one set of options that are going to work best.\n\n### Thread priority on Linux systems\n\nOn Linux systems that support [`nice(2)`][], Piscina is capable of setting\nthe priority of every worker in the pool. To use this mechanism, an additional\noptional native addon dependency (`nice-napi`, `npm i nice-napi`) is required.\nOnce [`nice-napi`][] is installed, creating a `Piscina` instance with the\n`niceIncrement` configuration option will set the priority for the pool:\n\n```js\nconst Piscina = require('piscina');\nconst pool = new Piscina({\n  worker: '/absolute/path/to/worker.js',\n  niceIncrement: 20\n});\n```\n\nThe higher the `niceIncrement`, the lower the CPU scheduling priority will be\nfor the pooled workers which will generally extend the execution time of\nCPU-bound tasks but will help prevent those threads from stealing CPU time from\nthe main Node.js event loop thread. Whether this is a good thing or not depends\nentirely on your application and will require careful profiling to get correct.\n\nThe key metrics to pay attention to when tuning the `niceIncrement` are the\nsampled run times of the tasks in the worker pool (using the [`runTime`][]\nproperty) and the [delay of the Node.js main thread event loop][].\n\n### Multiple Thread Pools and Embedding Piscina as a Dependency\n\nEvery `Piscina` instance creates a separate pool of threads and operates\nwithout any awareness of the other. When multiple pools are created in a\nsingle application the various threads may contend with one another, and\nwith the Node.js main event loop thread, and may cause an overall reduction\nin system performance.\n\nModules that embed Piscina as a dependency *should* make it clear via\ndocumentation that threads are being used. It would be ideal if those\nwould make it possible for users to provide an existing `Piscina` instance\nas a configuration option in lieu of always creating their own.\n\n\n## Release Notes\n\n### 2.1.0\n\n* Adds name property to indicate `AbortError` when tasks are\n  canceled using an `AbortController` (or similar)\n* More examples\n\n### 2.0.0\n\n* Added unmanaged file descriptor tracking\n* Updated dependencies\n\n### 1.6.1\n\n* Bug fix: Reject if AbortSignal is already aborted\n* Bug Fix: Use once listener for abort event\n\n### 1.6.0\n\n* Add the `niceIncrement` configuration parameter.\n\n### 1.5.1\n\n* Bug fixes around abortable task selection.\n\n### 1.5.0\n\n* Added `Piscina.move()`\n* Added Custom Task Queues\n* Added utilization metric\n* Wait for workers to be ready before considering them as candidates\n* Additional examples\n\n### 1.4.0\n\n* Added `maxQueue = 'auto'` to autocalculate the maximum queue size.\n* Added more examples, including an example of implementing a worker\n  as a Node.js native addon.\n\n### 1.3.0\n\n* Added the `'drain'` event\n\n### 1.2.0\n\n* Added support for ESM and file:// URLs\n* Added `env`, `argv`, `execArgv`, and `workerData` options\n* More examples\n\n### 1.1.0\n\n* Added support for Worker Thread `resourceLimits`\n\n### 1.0.0\n\n* Initial release!\n\n## The Team\n\n* James M Snell <jasnell@gmail.com>\n* Anna Henningsen <anna@addaleax.net>\n* Matteo Collina <matteo.collina@gmail.com>\n\n## Acknowledgements\n\nPiscina development is sponsored by [NearForm Research][].\n\n[`Atomics`]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics\n[`EventEmitter`]: https://nodejs.org/api/events.html\n[`postMessage`]: https://nodejs.org/api/worker_threads.html#worker_threads_port_postmessage_value_transferlist\n[`examples/task-queue`]: https://github.com/jasnell/piscina/blob/master/examples/task-queue/index.js\n[`nice(2)`]: https://linux.die.net/man/2/nice\n[`nice-napi`]: https://npmjs.org/package/nice-napi\n[`runTime`]: #property-runtime-readonly\n[Custom Task Queues]: #custom_task_queues\n[ES modules]: https://nodejs.org/api/esm.html\n[Node.js new Worker options]: https://nodejs.org/api/worker_threads.html#worker_threads_new_worker_filename_options\n[MIT Licensed]: LICENSE.md\n[NearForm Research]: https://www.nearform.com/research/\n[delay of the Node.js main thread event loop]: https://nodejs.org/dist/latest-v14.x/docs/api/perf_hooks.html#perf_hooks_perf_hooks_monitoreventloopdelay_options\n",
    "licenseText": "The MIT License (MIT)\n\nCopyright (c) 2020 James M Snell and the Piscina contributors\n\nPiscina contributors listed at https://github.com/jasnell/piscina#the-team and\nin the README file.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/piscina/-/piscina-2.2.0.tgz#8fd5236f07aaa9676c4100a3e4d90b6b7aaabf4c",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/piscina/-/piscina-2.2.0.tgz",
    "hash": "8fd5236f07aaa9676c4100a3e4d90b6b7aaabf4c",
    "integrity": "sha512-CQb0DfyTdC9FBIMYkVV/00fXRLKDjmWKA8S0N1zDg2JGEc5z3P9qHXtoq8OkJQ+vjCfXySkVonTNMqskMFOW/w==",
    "registry": "npm",
    "packageName": "piscina",
    "cacheIntegrity": "sha512-CQb0DfyTdC9FBIMYkVV/00fXRLKDjmWKA8S0N1zDg2JGEc5z3P9qHXtoq8OkJQ+vjCfXySkVonTNMqskMFOW/w== sha1-j9UjbweqqWdsQQCj5NkLa3qqv0w="
  },
  "registry": "npm",
  "hash": "8fd5236f07aaa9676c4100a3e4d90b6b7aaabf4c"
}